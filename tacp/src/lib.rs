#![allow(stable_features, non_camel_case_types)]
#![deny(unsafe_op_in_unsafe_fn)]
#![feature(allocator_api, layout_for_ptr)]
#![no_std]
extern crate alloc;

#[cfg(feature = "dst-construct")]
use alloc::boxed::Box;
#[cfg(feature = "dst-construct")]
use alloc::alloc::Allocator;

use argvalpair::ArgValPairIter;

use bitflags::bitflags;
use zerocopy::{KnownLayout, TryCastError, ConvertError};
use zerocopy_derive::{TryFromBytes, FromBytes, IntoBytes, KnownLayout, Immutable, Unaligned};
pub use zerocopy::byteorder::network_endian::{U32, U16};
pub use zerocopy::{IntoBytes, TryFromBytes, FromBytes};

#[cfg(feature = "obfuscation")]
pub mod obfuscation;
pub mod argvalpair;

#[cfg(feature = "dst-construct")]
/// Helper macro to precheck packet components before performing narrowing casts.
macro_rules! max {
    ($maxty:ty, $($val:expr),+) => {
        $(
            {
                if ($val.len()) > <$maxty>::MAX as usize {
                    Err(TacpErr::OversizedComponent { component_name: stringify!($val), component_size: $val.len(), max_size: <$maxty>::MAX as usize })
                }
                else { Ok(()) }?
            }
        )+
    };
}

#[cfg(feature = "dst-construct")]
/// Helper macro to precheck argument lengths before performing narrowing casts.
macro_rules! arg_len {
    ($args:ident) => {
        for (arg_idx, arg) in $args.iter().enumerate() {
            if arg.len() > u8::MAX as usize {
                Err(TacpErr::OversizedArgument { arg_index: arg_idx, arg_len: arg.len() })
            }
            else { Ok(()) }?
        }
    };
}

#[cfg(feature = "dst-construct")]
/// Helper macro to populate packet fields.
macro_rules! mem_cpy {
    ($mem: ident, $ptr: ident, $($ssrc:ident),+) => {
        $(
            $mem[$ptr..($ptr+$ssrc.len())].copy_from_slice($ssrc);
            $ptr += $ssrc.len();
        )+
    };
}

// Original protocol specification RFC 8907 https://datatracker.ietf.org/doc/html/rfc8907
// * Explains data structures, protocol operation, and deployment guidelines.
// Updated by RFC 9887 https://datatracker.ietf.org/doc/html/rfc9887
// * Deprecates the obfuscation method in the orginal protocol and replaces it with TLS, provides updated deployment guidelines.
//   Otherwise no protocol changes. So you will see quotes from original RFC used in most places throught the documentation of this crate.
//
// The following general rules apply to all TACACS+ packet types:
// * To signal that any variable-length data fields are unused, the corresponding length values are set to zero. Such fields MUST be ignored, and treated as if not present.
// * The lengths of data and message fields in a packet are specified by their corresponding length field (and are not null terminated).
// * All length values are unsigned and in network byte order.

/// TACACS+ Header Version Field
///
/// The TACACS+ protocol is versioned to allow revisions while maintaining backwards compatibility. The version number is in every packet header.
/// The changes between minor version 0 and 1 apply only to the authentication process, and all deal with the way that Challenge Handshake Authentication Protocol (CHAP)
/// and Password Authentication Protocol (PAP) authentications are handled.
/// PAP, CHAP, and MS-CHAP login use minor version 1. The normal exchange is a single START packet from the client and a single REPLY from the server.
/// All authorization and accounting and ASCII authentication use minor version 0.
#[repr(u8)]
#[derive(Copy, Clone, Debug, TryFromBytes, IntoBytes, KnownLayout, Immutable, PartialEq, Eq, Unaligned)]
pub enum Version {
    VersionDefault = 0xc << 4,
    VersionOne = (Self::VersionDefault as u8) | 0x1,
}


#[repr(u8)]
#[derive(Copy, Clone, Debug, TryFromBytes, IntoBytes, KnownLayout, Immutable, PartialEq, Eq, Unaligned)]
/// All TACACS+ packets are one of the following 3 types
pub enum PacketType {
    /// Authentication
    AUTHEN = 0x1,
    /// Authorization
    AUTHOR = 0x2,
    /// Accounting
    ACCT = 0x3,
}

/// This is the sequence number of the current packet.
///
/// The first packet in a session **MUST** have the sequence number 1, and each
/// subsequent packet will increment the sequence number by one.
/// TACACS+ clients only send packets containing odd sequence numbers,
/// and TACACS+ servers only send packets containing even sequence numbers.
///
/// The sequence number must never wrap, i.e., if the sequence number 2^8 - 1 is ever reached, that session must terminate and be restarted with a sequence number of 1.
pub type SeqNo = u8;

/// The ID for this TACACS+ session.
///
/// This field does not change for the duration of the TACACS+ session.
/// This number **MUST** be generated by a cryptographically strong random
/// number generation method.
///
/// Failure to do so will compromise security of the session. For more details, refer to RFC4086
pub type SessionID = U32;

/// The total length of the packet body (not including the header)
///
/// Implementations **MUST** allow control over maximum packet sizes
/// accepted by TACACS+ Servers. The recommended maximum packet size
/// is 2^12
pub type PacketLength = U32;

/**
All TACACS+ packets begin with the following 12-byte header.

Encoding:
```
1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8
+----------------+----------------+----------------+----------------+
|major  | minor  |                |                |                |
|version| version|      type      |     seq_no     |   flags        |
+----------------+----------------+----------------+----------------+
|                                                                   |
|                            session_id                             |
+----------------+----------------+----------------+----------------+
|                                                                   |
|                              length                               |
+----------------+----------------+----------------+----------------+
```
*/
#[repr(C, packed)]
#[derive(Copy, Clone, Debug, TryFromBytes, IntoBytes, KnownLayout, Immutable, Unaligned)]
pub struct PacketHeader {
    pub version: Version,
    pub ty: PacketType,
    pub seq_no: SeqNo,
    pub flags: Flags,
    pub session_id: SessionID,
    pub length: PacketLength,
}

impl PacketHeader {
    pub const fn new(version: Version, ty: PacketType, seq_no: SeqNo, flags: Flags, session_id: u32, length: u32) -> Self {
        Self { version, ty, seq_no, flags, session_id: U32::new(session_id), length: U32::new(length) }
    }
}

#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, KnownLayout, FromBytes, IntoBytes, Immutable, Unaligned)]
/// Flags for the TACACS+ Header
// All bits not defined (currently UNENCRYPTED and SINGLE_CONNECT) **MUST** be ignored when reading, and **SHOULD** be set to zero when writing
pub struct Flags(pub u8);

bitflags! {
    impl Flags: u8 {
        /// This flag indicates that the sender did not obfuscate the body of the packet. In modern deployments where TLS is used to secure the protocol,
        /// the built in obfuscation is obsoleted
        ///
        /// RFC 9887 ยง4
        /// > Peers MUST NOT use obfuscation with TLS. A TACACS+ client initiating a TACACS+ TLS connection MUST
        /// > set the TAC_PLUS_UNENCRYPTED_FLAG bit, thereby asserting that obfuscation is not used for the session.
        /// > All subsequent packets MUST have the TAC_PLUS_UNENCRYPTED_FLAG bit set to 1
        ///
        /// For legacy deployments where TLS is not used, this flag should be cleared so the built in obfuscation method is used, as that is better than nothing.
        ///
        /// RFC 8907 ยง4.1
        /// > This option **MUST** NOT be used in production This flag **SHOULD** be clear in all deployments.
        /// > Modern network traffic tools support encrypted traffic when configured with the shared secret, so obfuscated mode can and **SHOULD** be used even during test.
        ///
        const UNENCRYPTED = 0x1;
        /// This flag is used to allow a client and server to negotiate "Single Connection Mode" as defined in RFC 8907 ยง4.3
        const SINGLE_CONNECT = 0x4;
    }
}

/// Indicates the authentication action: login, change password, or the insecure and deprecated "sendauth"
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, KnownLayout, Unaligned, TryFromBytes, IntoBytes, Immutable)]
pub enum AuthenStartAction {
    LOGIN    = 0x1,
    CHPASS   = 0x2,
    SENDAUTH = 0x4,
}

/// Indicates what method of authentication is being requested/used.
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, KnownLayout, Unaligned, TryFromBytes, IntoBytes, Immutable)]
pub enum AuthenType {
    ASCII = 0x1,
    PAP = 0x2,
    CHAP = 0x3,
    MSCHAP_V1 = 0x5,
    MSCHAP_V2 = 0x6,
}

/// Privilege Level Packet Field
pub type PrivLevel = u8;

/// Indicates the Service that authentication is being requested for.
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, KnownLayout, Unaligned, TryFromBytes, IntoBytes, Immutable)]
pub enum AuthenService {
    NONE = 0x0,
    LOGIN = 0x1,
    ENABLE = 0x2,
    PPP = 0x3,
    PT = 0x5,
    RCMD = 0x6,
    X25 = 0x7,
    NASI = 0x8,
    FWPROXY = 0x9,
}

/**
The Authentication START Packet Body

Encoding:
```
1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8
+----------------+----------------+----------------+----------------+
|    action      |    priv_lvl    |  authen_type   | authen_service |
+----------------+----------------+----------------+----------------+
|    user_len    |    port_len    |  rem_addr_len  |    data_len    |
+----------------+----------------+----------------+----------------+
|    user ...
+----------------+----------------+----------------+----------------+
|    port ...
+----------------+----------------+----------------+----------------+
|    rem_addr ...
+----------------+----------------+----------------+----------------+
|    data...
+----------------+----------------+----------------+----------------+
```
*/
#[repr(C, packed)]
#[derive(KnownLayout, Immutable, TryFromBytes, IntoBytes, Unaligned)]
pub struct AuthenStartPacket {
    pub action: AuthenStartAction,
    pub priv_level: PrivLevel,
    pub authen_type: AuthenType,
    pub authen_svc: AuthenService,
    pub user_len: u8,
    pub port_len: u8,
    pub rem_addr_len: u8,
    pub data_len: u8,
    pub varidata: [u8]
}
impl AuthenStartPacket {
    pub fn get_user(&self) -> Option<&[u8]> {
        let start = 0usize;
        let end = self.user_len as usize;
        if end-start == 0 {
            return None;
        }
        Some(&self.varidata[start..end])
    }
    pub fn get_port(&self) -> Option<&[u8]> {
        let start = self.user_len as usize;
        let end = start + self.port_len as usize;
        if end-start == 0 {
            return None;
        }
        Some(&self.varidata[start..end])
    }
    pub fn get_rem_addr(&self) -> Option<&[u8]> {
        let start = self.user_len as usize + self.port_len as usize;
        let end = start + self.rem_addr_len as usize;
        if end-start == 0 {
            return None;
        }
        Some(&self.varidata[start..end])
    }
    pub fn get_data(&self) -> Option<&[u8]> {
        let start = self.user_len as usize + self.port_len as usize + self.rem_addr_len as usize;
        let end = start + self.data_len as usize;
        if end-start == 0 {
            return None;
        }
        Some(&self.varidata[start..end])
    }
    #[allow(clippy::missing_panics_doc, reason = "infallible")] // self had to be constructed so it can not be over the isize limit
    pub fn len(&self) -> usize {
        Self::size_for_metadata(self.varidata.len()).unwrap()
    }
}
#[cfg(feature = "dst-construct")]
impl AuthenStartPacket {
    #[doc=include_str!("untested_safety_msg.txt")]
    #[allow(clippy::missing_panics_doc, reason = "infallible")] // debug_assert + we shouldn't be having layout issues
    pub unsafe fn boxed_to_bytes<A: Allocator>(s: Box<Self, A>) -> Box<[u8], A> {
        use alloc::alloc::Layout;
        let real_len = s.len();
        let (ptr, allocator) = Box::into_raw_with_allocator(s);
        unsafe { debug_assert!(Layout::for_value_raw(ptr) == Layout::array::<u8>(real_len).unwrap()); }
        unsafe { Box::from_raw_in(core::ptr::slice_from_raw_parts_mut(ptr.cast::<u8>(), real_len), allocator) }
    }
    /// In-place initializer. If this returns Ok(()), you may perform a conversion to Self via TryFromBytes::try_mut_from_bytes
    ///
    /// # Errors
    ///
    /// Will return Err if not enough memory is provided to initilize the packet or if a variable length component exceeeds the maximum encodable size for this packet.
    ///
    /// | Component | Max Size |
    /// |:---------:|:--------:|
    /// |    user   |    255   |
    /// |    port   |    255   |
    /// |  rem_addr |    255   |
    /// |    data   |    255   |
    #[allow(clippy::missing_panics_doc, reason = "infallible")] // size_for_metadata only called after length ck + debug_assert
    pub fn initialize(mem: &mut [u8], action: AuthenStartAction, priv_level: PrivLevel, authen_type: AuthenType, authen_service: AuthenService, user: &[u8], port: &[u8], rem_addr: &[u8], data: &[u8]) -> Result<(), TacpErr> {
        max!(u8, user, port, rem_addr, data);
        let len = mem.len();
        let required_mem = Self::size_for_metadata(user.len() + port.len() + rem_addr.len() + data.len()).unwrap();
        if len < required_mem {
            return Err(TacpErr::BufferSize { required_size: required_mem, given_size: len });
        }
        mem[0] = action as u8;
        mem[1] = priv_level;
        mem[2] = authen_type as u8;
        mem[3] = authen_service as u8;
        #[allow(clippy::cast_possible_truncation)] {
        mem[4] = user.len() as u8;
        mem[5] = port.len() as u8;
        mem[6] = rem_addr.len() as u8;
        mem[7] = data.len() as u8;
        }
        let mut varidata_ptr = Self::size_for_metadata(0usize).unwrap();
        mem_cpy!(mem, varidata_ptr, user, port, rem_addr, data);
        debug_assert!(varidata_ptr == required_mem);
        Ok(())
    }
    #[doc=include_str!("untested_safety_msg.txt")]
    ///
    /// # Errors
    ///
    /// Will return Err on allocation failure or if a variable length component exceeeds the maximum encodable size for this packet.
    ///
    /// | Component | Max Size |
    /// |:---------:|:--------:|
    /// |    user   |    255   |
    /// |    port   |    255   |
    /// |  rem_addr |    255   |
    /// |    data   |    255   |
    #[allow(clippy::missing_panics_doc, reason = "infallible")] // size_for_metadata only called after length ck
    pub unsafe fn new_in<A: Allocator>(the_alloc: A, action: AuthenStartAction, priv_level: PrivLevel, authen_type: AuthenType, authen_service: AuthenService, user: &[u8], port: &[u8], rem_addr: &[u8], data: &[u8]) -> Result<Box<Self, A>, TacpErr> {unsafe {
        use core::alloc::Layout;
        use core::slice::from_raw_parts_mut as mk_slice;
        use core::ptr::NonNull;
        max!(u8, user, port, rem_addr, data);
        let len = Self::size_for_metadata(user.len() + port.len() + rem_addr.len() + data.len()).unwrap();
        let layout = Layout::array::<u8>(len)?;
        let ptr = the_alloc.allocate(layout)?.as_ptr().cast::<u8>();
        if let Err(e) = Self::initialize(mk_slice(ptr, len), action, priv_level, authen_type, authen_service, user, port, rem_addr, data) {
            the_alloc.deallocate(NonNull::new_unchecked(ptr), layout);
            return Err(e);
        }
        let sliced = mk_slice(ptr, len);
        let typed_ptr = match Self::try_mut_from_bytes(sliced) {
            Ok(typed_ref) => core::ptr::from_mut(typed_ref),
            Err(e) => {
                let e: TacpErr = e.into();
                the_alloc.deallocate(NonNull::new_unchecked(ptr), layout);
                return Err(e);
            },
        };
        Ok(Box::from_raw_in(typed_ptr, the_alloc))
    }}
    #[doc=include_str!("untested_safety_msg.txt")]
    ///
    /// # Errors
    ///
    /// Will return Err on allocation failure or if a variable length component exceeeds the maximum encodable size for this packet.
    ///
    /// | Component | Max Size |
    /// |:---------:|:--------:|
    /// |    user   |    255   |
    /// |    port   |    255   |
    /// |  rem_addr |    255   |
    /// |    data   |    255   |
    pub unsafe fn new(action: AuthenStartAction, priv_level: PrivLevel, authen_type: AuthenType, authen_service: AuthenService, user: &[u8], port: &[u8], rem_addr: &[u8], data: &[u8]) -> Result<Box<Self>, TacpErr> {unsafe {
        Self::new_in(alloc::alloc::Global, action, priv_level, authen_type, authen_service, user, port, rem_addr, data)
    }}
}

#[repr(u8)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, KnownLayout, Unaligned, TryFromBytes, IntoBytes, Immutable)]
/// Status field for Authentication Reply Packets
pub enum AuthenReplyStatus {
    PASS = 0x01,
    FAIL = 0x02,
    GETDATA = 0x03,
    GETUSER = 0x04,
    GETPASS = 0x05,
    RESTART = 0x06,
    ERROR = 0x07,
    FOLLOW = 0x21,
}

/**
The Authentication REPLY Packet Body

Encoding:
```
 1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8
+----------------+----------------+----------------+----------------+
|     status     |      flags     |        server_msg_len           |
+----------------+----------------+----------------+----------------+
|           data_len              |        server_msg ...
+----------------+----------------+----------------+----------------+
|           data ...
+----------------+----------------+
```
*/
#[repr(C, packed)]
#[derive(KnownLayout, Unaligned, TryFromBytes, IntoBytes, Immutable)]
pub struct AuthenReplyPacket {
    pub status: AuthenReplyStatus,
    pub flags: AuthenReplyFlags,
    pub serv_msg_len: U16,
    pub data_len: U16,
    pub varidata: [u8],
}
impl AuthenReplyPacket {
    pub fn get_serv_msg(&self) -> Option<&[u8]> {
        let start = 0;
        let end = self.serv_msg_len.get() as usize;
        if end-start == 0 {
            return None;
        }
        Some(&self.varidata[start..end])
    }
    pub fn get_data(&self) -> Option<&[u8]> {
        let start = self.serv_msg_len.get() as usize;
        let end = start + self.data_len.get() as usize;
        if end-start == 0 {
            return None;
        }
        Some(&self.varidata[start..end])
    }
    #[allow(clippy::missing_panics_doc, reason = "infallible")] // self had to be constructed so it can not be over the isize limit
    pub fn len(&self) -> usize {
        Self::size_for_metadata(self.data_len.get() as usize + self.serv_msg_len.get() as usize).unwrap()
    }
}
#[cfg(feature = "dst-construct")]
impl AuthenReplyPacket {
    #[doc=include_str!("untested_safety_msg.txt")]
    #[allow(clippy::missing_panics_doc, reason = "infallible")] // debug_assert + we shouldn't be having layout issues
    pub unsafe fn boxed_to_bytes<A: Allocator>(s: Box<Self, A>) -> Box<[u8], A> {
        use alloc::alloc::Layout;
        let real_len = s.len();
        let (ptr, allocator) = Box::into_raw_with_allocator(s);
        unsafe { debug_assert!(Layout::for_value_raw(ptr) == Layout::array::<u8>(real_len).unwrap()); }
        unsafe { Box::from_raw_in(core::ptr::slice_from_raw_parts_mut(ptr.cast::<u8>(), real_len), allocator) }
    }
    /// In-place initializer. If this returns Ok(()), you may perform a conversion to Self via TryFromBytes::try_mut_from_bytes
    ///
    /// # Errors
    ///
    /// Will return Err if not enough memory is provided to initilize the packet or if a variable length component exceeeds the maximum encodable size for this packet.
    ///
    /// | Component | Max Size |
    /// |:---------:|:--------:|
    /// |  serv_msg |   65535  |
    /// |    data   |   65535  |
    #[allow(clippy::missing_panics_doc, reason = "infallible")] // size_for_metadata only called after length ck + debug_assert
    pub fn initialize(mem: &mut [u8], status: AuthenReplyStatus, flags: AuthenReplyFlags, serv_msg: &[u8], data: &[u8]) -> Result<(), TacpErr> {
        max!(u16, serv_msg, data);
        let len = mem.len();
        let required_mem = Self::size_for_metadata(serv_msg.len()+data.len()).unwrap();
        if len < required_mem {
            return Err(TacpErr::BufferSize { required_size: required_mem, given_size: len });
        }
        #[allow(clippy::cast_possible_truncation)]
        let serv_msg_len = U16::new(serv_msg.len() as u16);
        let serv_msg_bytes = serv_msg_len.as_bytes();
        #[allow(clippy::cast_possible_truncation)]
        let data_len = U16::new(data.len() as u16);
        let data_len_bytes = data_len.as_bytes();
        mem[0] = status as u8;
        mem[1] = flags.0;
        mem[2] = serv_msg_bytes[0];
        mem[3] = serv_msg_bytes[1];
        mem[4] = data_len_bytes[0];
        mem[5] = data_len_bytes[1];
        let mut varidata_ptr = Self::size_for_metadata(0usize).unwrap();
        mem_cpy!(mem, varidata_ptr, serv_msg, data);
        debug_assert!(varidata_ptr == required_mem);
        Ok(())
    }
    #[doc=include_str!("untested_safety_msg.txt")]
    ///
    /// # Errors
    ///
    /// Will return Err on allocation failure or if a variable length component exceeeds the maximum encodable size for this packet.
    ///
    /// | Component | Max Size |
    /// |:---------:|:--------:|
    /// |  serv_msg |   65535  |
    /// |    data   |   65535  |
    #[allow(clippy::missing_panics_doc, reason = "infallible")] // size_for_metadata only called after length ck
    pub unsafe fn new_in<A: Allocator>(the_alloc: A, status: AuthenReplyStatus, flags: AuthenReplyFlags, serv_msg: &[u8], data: &[u8]) -> Result<Box<Self, A>, TacpErr> { unsafe {
        use core::alloc::Layout;
        use core::slice::from_raw_parts_mut as mk_slice;
        use core::ptr::NonNull;
        max!(u16, serv_msg, data);
        let len = Self::size_for_metadata(serv_msg.len() + data.len()).unwrap();
        let layout = Layout::array::<u8>(len)?;
        let ptr = the_alloc.allocate(layout)?.as_ptr().cast::<u8>();
        if let Err(e) = Self::initialize(mk_slice(ptr, len), status, flags, serv_msg, data) {
            the_alloc.deallocate(NonNull::new_unchecked(ptr), layout);
            return Err(e);
        }
        let sliced = mk_slice(ptr, len);
        let typed_ptr = match Self::try_mut_from_bytes(sliced) {
            Ok(typed_ref) => core::ptr::from_mut(typed_ref),
            Err(e) => {
                let e: TacpErr = e.into();
                the_alloc.deallocate(NonNull::new_unchecked(ptr), layout);
                return Err(e);
            },
        };
        Ok(Box::from_raw_in(typed_ptr, the_alloc))
    }}
    #[doc=include_str!("untested_safety_msg.txt")]
    ///
    /// # Errors
    ///
    /// Will return Err on allocation failure or if a variable length component exceeeds the maximum encodable size for this packet.
    ///
    /// | Component | Max Size |
    /// |:---------:|:--------:|
    /// |  serv_msg |   65535  |
    /// |    data   |   65535  |
    pub unsafe fn new(status: AuthenReplyStatus, flags: AuthenReplyFlags, serv_msg: &[u8], data: &[u8]) -> Result<Box<Self>, TacpErr> { unsafe {
        Self::new_in(alloc::alloc::Global, status, flags, serv_msg, data)
    }}
}

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, KnownLayout, Immutable, Unaligned, FromBytes, IntoBytes)]
/// Flags for the Authentication Reply packet
pub struct AuthenReplyFlags(pub u8);

bitflags! {
    impl AuthenReplyFlags: u8 {
        /// If the information being requested by the server from the client is sensitive, then the server should set
        /// the this flag. When the client queries the user for the information, the response MUST NOT be reflected in
        /// the user interface as it is entered.
        const REPLY_NOECHO = 1;
    }
}

/**
Authentication CONTINUE Packet Body

This packet is sent from the client to the server following the receipt of a REPLY packet.

Encoding:
```

1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8
+----------------+----------------+----------------+----------------+
|          user_msg len           |            data_len             |
+----------------+----------------+----------------+----------------+
|     flags      |  user_msg ...
+----------------+----------------+----------------+----------------+
|    data ...
+----------------+
```
*/
#[repr(C, packed)]
#[derive(KnownLayout, Unaligned, TryFromBytes, IntoBytes, Immutable)]
pub struct AuthenContinuePacket {
    pub user_msg_len: U16,
    pub data_len: U16,
    pub flags: AuthenContinueFlags,
    pub varidata: [u8],
}

impl AuthenContinuePacket {
    pub fn get_user_msg(&self) -> Option<&[u8]> {
        let start = 0;
        let end = self.user_msg_len.get() as usize;
        if end-start == 0 {
            return None;
        }
        Some(&self.varidata[start..end])
    }
    pub fn get_data(&self) -> Option<&[u8]> {
        let start = self.user_msg_len.get() as usize;
        let end = start + self.data_len.get() as usize;
        if end-start == 0 {
            return None;
        }
        Some(&self.varidata[start..end])
    }
    #[allow(clippy::missing_panics_doc, reason = "infallible")] // self had to be constructed so it can not be over the isize limit
    pub fn len(&self) -> usize {
        Self::size_for_metadata(self.user_msg_len.get() as usize + self.data_len.get() as usize).unwrap()
    }
}
#[cfg(feature = "dst-construct")]
impl AuthenContinuePacket {
    #[doc=include_str!("untested_safety_msg.txt")]
    #[allow(clippy::missing_panics_doc, reason = "infallible")] // debug_assert + we shouldn't be having layout issues
    pub unsafe fn boxed_to_bytes<A: Allocator>(s: Box<Self, A>) -> Box<[u8], A> {
        use alloc::alloc::Layout;
        let real_len = s.len();
        let (ptr, allocator) = Box::into_raw_with_allocator(s);
        unsafe { debug_assert!(Layout::for_value_raw(ptr) == Layout::array::<u8>(real_len).unwrap()); }
        unsafe { Box::from_raw_in(core::ptr::slice_from_raw_parts_mut(ptr.cast::<u8>(), real_len), allocator) }
    }
    /// In-place initializer. If this returns Ok(()), you may perform a conversion to Self via TryFromBytes::try_mut_from_bytes
    ///
    /// # Errors
    ///
    /// Will return Err if not enough memory is provided to initilize the packet or if a variable length component exceeeds the maximum encodable size for this packet.
    ///
    /// | Component | Max Size |
    /// |:---------:|:--------:|
    /// |  user_msg |   65535  |
    /// |    data   |   65535  |
    #[allow(clippy::missing_panics_doc, reason = "infallible")] // size_for_metadata only called after length ck + debug_assert
    pub fn initialize(mem: &mut [u8], flags: AuthenContinueFlags, user_msg: &[u8], data: &[u8]) -> Result<(), TacpErr> {
        max!(u16, user_msg, data);
        let len = mem.len();
        let required_mem = Self::size_for_metadata(user_msg.len() + data.len()).unwrap();
        if len < required_mem {
            return Err(TacpErr::BufferSize { required_size: required_mem, given_size: len });
        }
        #[allow(clippy::cast_possible_truncation)]
        let user_msg_len_be = U16::new(user_msg.len() as u16);
        #[allow(clippy::cast_possible_truncation)]
        let data_len_be = U16::new(data.len() as u16);
        let user_msg_len_bytes = user_msg_len_be.as_bytes();
        let data_len_bytes = data_len_be.as_bytes();
        mem[0] = user_msg_len_bytes[0];
        mem[1] = user_msg_len_bytes[1];
        mem[2] = data_len_bytes[0];
        mem[3] = data_len_bytes[1];
        mem[4] = flags.0;
        let mut varidata_ptr = Self::size_for_metadata(0usize).unwrap();
        mem_cpy!(mem, varidata_ptr, user_msg, data);
        debug_assert!(varidata_ptr == required_mem);
        Ok(())
    }
    #[doc=include_str!("untested_safety_msg.txt")]
    ///
    /// # Errors
    ///
    /// Will return Err if not enough memory is provided to initilize the packet or if a variable length component exceeeds the maximum encodable size for this packet.
    ///
    /// | Component | Max Size |
    /// |:---------:|:--------:|
    /// |  user_msg |   65535  |
    /// |    data   |   65535  |
    #[allow(clippy::missing_panics_doc, reason = "infallible")] // size_for_metadata only called after length ck
    pub unsafe fn new_in<A: Allocator>(the_alloc: A, flags: AuthenContinueFlags, user_msg: &[u8], data: &[u8]) -> Result<Box<Self, A>, TacpErr> {unsafe {
        use core::alloc::Layout;
        use core::slice::from_raw_parts_mut as mk_slice;
        use core::ptr::NonNull;
        max!(u16, user_msg, data);
        let len = Self::size_for_metadata(user_msg.len() + data.len()).unwrap();
        let layout = Layout::array::<u8>(len)?;
        let ptr = the_alloc.allocate(layout)?.as_ptr().cast::<u8>();
        if let Err(e) = Self::initialize(mk_slice(ptr, len), flags, user_msg, data) {
            the_alloc.deallocate(NonNull::new_unchecked(ptr), layout);
            return Err(e);
        }
        let sliced = mk_slice(ptr, len);
        let typed_ptr = match Self::try_mut_from_bytes(sliced) {
            Ok(typed_ref) => core::ptr::from_mut(typed_ref),
            Err(e) => {
                let e: TacpErr = e.into();
                the_alloc.deallocate(NonNull::new_unchecked(ptr), layout);
                return Err(e);
            },
        };
        Ok(Box::from_raw_in(typed_ptr, the_alloc))
    }}
    #[doc=include_str!("untested_safety_msg.txt")]
    ///
    /// # Errors
    ///
    /// Will return Err if not enough memory is provided to initilize the packet or if a variable length component exceeeds the maximum encodable size for this packet.
    ///
    /// | Component | Max Size |
    /// |:---------:|:--------:|
    /// |  user_msg |   65535  |
    /// |    data   |   65535  |
    pub unsafe fn new(flags: AuthenContinueFlags, user_msg: &[u8], data: &[u8]) -> Result<Box<Self>, TacpErr> {unsafe {
        Self::new_in(alloc::alloc::Global, flags, user_msg, data)
    }}
}

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, KnownLayout, Immutable, Unaligned, FromBytes, IntoBytes)]
/// Flags for the Authentication Continue Packet
pub struct AuthenContinueFlags(pub u8);

bitflags! {
    impl AuthenContinueFlags: u8 {
        /// The client may prematurely terminate a session by setting the TAC_PLUS_CONTINUE_FLAG_ABORT flag in the CONTINUE message.
        /// If this flag is set, the data portion of the message may contain a text explaining the reason for the abort. This text will
        /// be handled by the server according to the requirements of the deployment.
        const FLAG_ABORT = 1;
    }
}


/// Indicates the authentication method used to acquire user information
///
/// As this information is not always subject to verification, it MUST NOT be used in policy evaluation.
/// LINE refers to a fixed password associated with the terminal line used to gain access.
/// LOCAL is a client local user database. ENABLE is a command that authenticates in order to grant new privileges.
/// TACACSPLUS is, of course, TACACS+. GUEST is an unqualified guest authentication.
/// RADIUS is the RADIUS authentication protocol. RCMD refers to authentication provided via the R-command protocols from Berkeley Unix.
/// KRB5 \[RFC4120\] and KRB4 \[KRB4\] are Kerberos versions 5 and 4.
/// As mentioned above, this field is used by the client to indicate how it performed the authentication.
/// One of the options (`TAC_PLUS_AUTHEN_METH_TACACSPLUS` := 0x06) is TACACS+ itself, and so the detail of how the client performed this option is given in "Authentication" (Section 5).
/// For all other options, such as KRB and RADIUS, the TACACS+ protocol did not play any part in the authentication phase;
/// as those interactions were not conducted using the TACACS+ protocol, they will not be documented here.
/// For implementers of clients who need details of the other protocols, please refer to the respective Kerberos \[RFC4120\] and RADIUS \[RFC3579\] RFCs.
#[repr(u8)]
#[derive(Debug, Clone, Copy, KnownLayout, Unaligned, TryFromBytes, IntoBytes, Immutable)]
pub enum AuthorMethod {
    NOT_SET = 0x00,
    NONE = 0x01,
    KRB5 = 0x02,
    LINE = 0x03,
    ENABLE = 0x04,
    LOCAL = 0x05,
    TACACSPLUS = 0x06,
    GUEST = 0x08,
    RADIUS = 0x10,
    KRB4 = 0x11,
    RCMD = 0x20,
}

/**
The Authroization REQUEST Packet Body

Encoding:
```
  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8
+----------------+----------------+----------------+----------------+
|  authen_method |    priv_lvl    |  authen_type   | authen_service |
+----------------+----------------+----------------+----------------+
|    user_len    |    port_len    |  rem_addr_len  |    arg_cnt     |
+----------------+----------------+----------------+----------------+
|   arg_1_len    |   arg_2_len    |      ...       |   arg_N_len    |
+----------------+----------------+----------------+----------------+
|   user ...
+----------------+----------------+----------------+----------------+
|   port ...
+----------------+----------------+----------------+----------------+
|   rem_addr ...
+----------------+----------------+----------------+----------------+
|   arg_1 ...
+----------------+----------------+----------------+----------------+
|   arg_2 ...
+----------------+----------------+----------------+----------------+
|   ...
+----------------+----------------+----------------+----------------+
|   arg_N ...
+----------------+----------------+----------------+----------------+
```
*/
#[repr(C, packed)]
#[derive(KnownLayout, Unaligned, TryFromBytes, IntoBytes, Immutable)]
pub struct AuthorRequestPacket {
    pub method: AuthorMethod,
    pub priv_level: PrivLevel,
    pub authen_type: AuthenType,
    pub authen_svc: AuthenService,
    pub user_len: u8,
    pub port_len: u8,
    pub rem_addr_len: u8,
    pub arg_cnt: u8,
    pub varidata: [u8]
}

impl AuthorRequestPacket {
    pub fn get_user(&self) -> Option<&[u8]> {
        let start = self.arg_cnt as usize;
        let end = start + self.user_len as usize;
        if end-start == 0 {
            return None;
        }
        Some(&self.varidata[start..end])
    }
    pub fn get_port(&self) -> Option<&[u8]> {
        let start = self.arg_cnt as usize + self.user_len as usize;
        let end = start + self.port_len as usize;
        if end-start == 0 {
            return None;
        }
        Some(&self.varidata[start..end])
    }
    pub fn get_rem_addr(&self) -> Option<&[u8]> {
        let start = self.arg_cnt as usize + self.user_len as usize + self.port_len as usize;
        let end = start + self.rem_addr_len as usize;
        if end-start == 0 {
            return None;
        }
        Some(&self.varidata[start..end])
    }
    pub fn get_raw_argvalpair(&self, idx: u8) -> Option<&[u8]> {
        if idx > self.arg_cnt {
            return None;
        }
        let arg_len = self.varidata[idx as usize] as usize;
        let mut skip = 
            self.arg_cnt as usize
            + self.user_len as usize
            + self.port_len as usize
            + self.rem_addr_len as usize;
        for n in 0..idx {
            skip += self.varidata[n as usize] as usize;
        }
        Some(&self.varidata[skip..(skip+arg_len)])
    }
    pub fn iter_args(&self) -> ArgValPairIter<'_> {
        let lengths_range = 0..(self.arg_cnt as usize);
        let data_range_base = 
            self.arg_cnt as usize + self.user_len as usize + self.port_len as usize + self.rem_addr_len as usize;
        ArgValPairIter::new(self.arg_cnt, &self.varidata[lengths_range], &self.varidata[data_range_base..])
    }
    #[allow(clippy::missing_panics_doc, reason = "infallible")] // self had to be constructed so it can not be over the isize limit
    pub fn len(&self) -> usize {
        Self::size_for_metadata(self.varidata.len()).unwrap()
    }
}
#[cfg(feature = "dst-construct")]
impl AuthorRequestPacket {
    #[doc=include_str!("untested_safety_msg.txt")]
    #[allow(clippy::missing_panics_doc, reason = "infallible")] // debug_assert + we shouldn't be having layout issues
    pub unsafe fn boxed_to_bytes<A: Allocator>(s: Box<Self, A>) -> Box<[u8], A> {
        use alloc::alloc::Layout;
        let real_len = s.len();
        let (ptr, allocator) = Box::into_raw_with_allocator(s);
        unsafe { debug_assert!(Layout::for_value_raw(ptr) == Layout::array::<u8>(real_len).unwrap()); }
        unsafe { Box::from_raw_in(core::ptr::slice_from_raw_parts_mut(ptr.cast::<u8>(), real_len), allocator) }
    }
    /// In-place initializer. If this returns Ok(()), you may perform a conversion to Self via TryFromBytes::try_mut_from_bytes
    ///
    /// # Errors
    ///
    /// Will return Err if not enough memory is provided to initilize the packet or if a variable length component exceeeds the maximum encodable size for this packet.
    ///
    /// | Component | Max Size |
    /// |:---------:|:--------:|
    /// |    user   |    255   |
    /// |    port   |    255   |
    /// |  rem_addr |    255   |
    /// | # of args |    255   |
    /// |  each arg |    255   |
    #[allow(clippy::missing_panics_doc, reason = "infallible")] // size_for_metadata only called after length ck + debug_assert
    pub fn initialize(mem: &mut [u8], method: AuthorMethod, priv_level: PrivLevel, authen_type: AuthenType, authen_svc: AuthenService, user: &[u8], port: &[u8], rem_addr: &[u8], args:&[&[u8]]) -> Result<(), TacpErr> {
        max!(u8, user,  port, rem_addr, args);
        arg_len!(args);
        let len = mem.len();
        let required_mem = Self::size_for_metadata(user.len() + port.len() + rem_addr.len() + args.len() + args.iter().fold(0, |acc, arg|acc+arg.len())).unwrap();
        if len < required_mem {
            return Err(TacpErr::BufferSize { required_size: required_mem, given_size: len });
        }
        mem[0] = method as u8;
        mem[1] = priv_level;
        mem[2] = authen_type as u8;
        mem[3] = authen_svc as u8;
        #[allow(clippy::cast_possible_truncation)] {
        mem[4] = user.len() as u8;
        mem[5] = port.len() as u8;
        mem[6] = rem_addr.len() as u8;
        mem[7] = args.len() as u8;
        }
        let fixed_part = Self::size_for_metadata(0usize).unwrap();
        let mut varidata_ptr = fixed_part + args.len();
        mem_cpy!(mem, varidata_ptr, user, port, rem_addr);
        for (arg_idx, arg) in args.iter().enumerate() {
            #[allow(clippy::cast_possible_truncation)]
            let arg_len = arg.len() as u8;
            mem[fixed_part+arg_idx] = arg_len;
            mem[varidata_ptr..(varidata_ptr+arg_len as usize)].copy_from_slice(arg);
            varidata_ptr += arg_len as usize;
        }
        debug_assert!(varidata_ptr == required_mem);
        Ok(())
    }
    #[doc=include_str!("untested_safety_msg.txt")]
    ///
    /// # Errors
    ///
    /// Will return Err on allocation failure or if a variable length component exceeeds the maximum encodable size for this packet.
    ///
    /// | Component | Max Size |
    /// |:---------:|:--------:|
    /// |    user   |    255   |
    /// |    port   |    255   |
    /// |  rem_addr |    255   |
    /// | # of args |    255   |
    /// |  each arg |    255   |
    #[allow(clippy::missing_panics_doc, reason = "infallible")] // size_for_metadata only called after length ck
    pub unsafe fn new_in<A: Allocator>(the_alloc: A, method: AuthorMethod, priv_level: PrivLevel, authen_type: AuthenType, authen_svc: AuthenService, user: &[u8], port: &[u8], rem_addr: &[u8], args:&[&[u8]]) -> Result<Box<Self, A>, TacpErr> {unsafe {
        use core::alloc::Layout;
        use core::slice::from_raw_parts_mut as mk_slice;
        use core::ptr::NonNull;
        max!(u8, user,  port, rem_addr, args);
        arg_len!(args);
        let len = Self::size_for_metadata(user.len() + port.len() + rem_addr.len() + args.len() + args.iter().fold(0, |acc, arg|acc+arg.len())).unwrap();
        let layout = Layout::array::<u8>(len)?;
        let ptr = the_alloc.allocate(layout)?.as_ptr().cast::<u8>();
        if let Err(e) = Self::initialize(mk_slice(ptr, len), method, priv_level, authen_type, authen_svc, user, port, rem_addr, args) {
            the_alloc.deallocate(NonNull::new_unchecked(ptr), layout);
            return Err(e);
        }
        let sliced = mk_slice(ptr, len);
        let typed_ptr = match Self::try_mut_from_bytes(sliced) {
            Ok(typed_ref) => core::ptr::from_mut(typed_ref),
            Err(e) => {
                let e: TacpErr = e.into();
                the_alloc.deallocate(NonNull::new_unchecked(ptr), layout);
                return Err(e);
            },
        };
        Ok(Box::from_raw_in(typed_ptr, the_alloc))
    }}
    #[doc=include_str!("untested_safety_msg.txt")]
    ///
    /// # Errors
    ///
    /// Will return Err on allocation failure or if a variable length component exceeeds the maximum encodable size for this packet.
    ///
    /// | Component | Max Size |
    /// |:---------:|:--------:|
    /// |    user   |    255   |
    /// |    port   |    255   |
    /// |  rem_addr |    255   |
    /// | # of args |    255   |
    /// |  each arg |    255   |
    pub unsafe fn new(method: AuthorMethod, priv_level: PrivLevel, authen_type: AuthenType, authen_svc: AuthenService, user: &[u8], port: &[u8], rem_addr: &[u8], args:&[&[u8]]) -> Result<Box<Self>, TacpErr> {unsafe {
        Self::new_in(alloc::alloc::Global, method, priv_level, authen_type, authen_svc, user, port, rem_addr, args)
    }}
}

/**
The Authorization REPLY Packet Body

Encoding:
```
 1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8
+----------------+----------------+----------------+----------------+
|    status      |     arg_cnt    |         server_msg len          |
+----------------+----------------+----------------+----------------+
+            data_len             |    arg_1_len   |    arg_2_len   |
+----------------+----------------+----------------+----------------+
|      ...       |   arg_N_len    |         server_msg ...
+----------------+----------------+----------------+----------------+
|   data ...
+----------------+----------------+----------------+----------------+
|   arg_1 ...
+----------------+----------------+----------------+----------------+
|   arg_2 ...
+----------------+----------------+----------------+----------------+
|   ...
+----------------+----------------+----------------+----------------+
|   arg_N ...
+----------------+----------------+----------------+----------------+
```
*/
#[repr(C, packed)]
#[derive(KnownLayout, Unaligned, TryFromBytes, IntoBytes, Immutable)]
pub struct AuthorReplyPacket {
    pub status: AuthorStatus,
    pub arg_cnt: u8,
    pub server_msg_len: U16,
    pub data_len: U16,
    pub varidata: [u8],
}

impl AuthorReplyPacket {
    pub fn get_serv_msg(&self) -> Option<&[u8]> {
        let start = self.arg_cnt as usize;
        let end = start+self.server_msg_len.get() as usize;
        if end-start == 0 {
            return None;
        }
        Some(&self.varidata[start..end])
    }
    pub fn get_data(&self) -> Option<&[u8]> {
        let start = self.arg_cnt as usize + self.server_msg_len.get() as usize;
        let end = start+self.data_len.get() as usize;
        if end-start == 0 {
            return None;
        }
        Some(&self.varidata[start..end])
    }
    pub fn get_raw_argvalpair(&self, idx: u8) -> Option<&[u8]> {
        if idx > self.arg_cnt {
            return None;
        }
        let arg_len = self.varidata[idx as usize] as usize;
        let mut skip = 
            self.arg_cnt as usize
            + self.server_msg_len.get() as usize
            + self.data_len.get() as usize;
        for n in 0..idx {
            skip += self.varidata[n as usize] as usize;
        }
        Some(&self.varidata[skip..(skip+arg_len)])
    }
    pub fn iter_args(&self) -> ArgValPairIter<'_> {
        let lengths_range = 0..(self.arg_cnt as usize);
        let data_range_base = 
            self.arg_cnt as usize + self.server_msg_len.get() as usize + self.data_len.get() as usize;
        ArgValPairIter::new(self.arg_cnt, &self.varidata[lengths_range], &self.varidata[data_range_base..])
    }
    #[allow(clippy::missing_panics_doc, reason = "infallible")] // self had to be constructed so it can not be over the isize limit
    pub fn len(&self) -> usize {
        Self::size_for_metadata(self.varidata.len()).unwrap()
    }
}
#[cfg(feature = "dst-construct")]
impl AuthorReplyPacket {
    #[doc=include_str!("untested_safety_msg.txt")]
    #[allow(clippy::missing_panics_doc, reason = "infallible")] // debug_assert + we shouldn't be having layout issues
    pub unsafe fn boxed_to_bytes<A: Allocator>(s: Box<Self, A>) -> Box<[u8], A> {
        use alloc::alloc::Layout;
        let real_len = s.len();
        let (ptr, allocator) = Box::into_raw_with_allocator(s);
        unsafe { debug_assert!(Layout::for_value_raw(ptr) == Layout::array::<u8>(real_len).unwrap()); }
        unsafe { Box::from_raw_in(core::ptr::slice_from_raw_parts_mut(ptr.cast::<u8>(), real_len), allocator) }
    }
    /// In-place initializer. If this returns Ok(()), you may perform a conversion to Self via TryFromBytes::try_mut_from_bytes
    ///
    /// # Errors
    ///
    /// Will return Err if not enough memory is provided to initilize the packet or if a variable length component exceeeds the maximum encodable size for this packet.
    ///
    /// | Component | Max Size |
    /// |:---------:|:--------:|
    /// |  serv_msg |   65535  |
    /// |    data   |   65535  |
    /// | # of args |    255   |
    /// |  each arg |    255   |
    #[allow(clippy::missing_panics_doc, reason = "infallible")] // size_for_metadata only called after length ck + debug_assert
    pub fn initialize(mem: &mut [u8], status: AuthorStatus, args: &[&[u8]], server_msg: &[u8], data: &[u8]) -> Result<(), TacpErr> {
        max!(u8, args);
        max!(u16, server_msg, data);
        arg_len!(args);
        let len = mem.len();
        let required_mem = Self::size_for_metadata(server_msg.len() + data.len() + args.len() + args.iter().fold(0, |acc, arg|acc+arg.len())).unwrap();
        if len < required_mem {
            return Err(TacpErr::BufferSize { required_size: required_mem, given_size: len });
        }
        mem[0] = status as u8;
        #[allow(clippy::cast_possible_truncation)] {
        mem[1] = args.len() as u8;
        let server_msg_len_be = U16::new(server_msg.len() as u16);
        let data_len_be = U16::new(data.len() as u16);
        let server_msg_len_bytes = server_msg_len_be.as_bytes();
        let data_len_bytes = data_len_be.as_bytes();
        mem[2] = server_msg_len_bytes[0];
        mem[3] = server_msg_len_bytes[1];
        mem[4] = data_len_bytes[0];
        mem[5] = data_len_bytes[1];
        }
        let fixed_part = Self::size_for_metadata(0usize).unwrap();
        let mut varidata_ptr = fixed_part + args.len();
        mem_cpy!(mem, varidata_ptr, server_msg, data);
        for (arg_idx, arg) in args.iter().enumerate() {
            #[allow(clippy::cast_possible_truncation)]
            let arg_len = arg.len() as u8;
            mem[fixed_part+arg_idx] = arg_len;
            mem[varidata_ptr..(varidata_ptr+arg_len as usize)].copy_from_slice(arg);
            varidata_ptr += arg_len as usize;
        }
        debug_assert!(varidata_ptr == required_mem);
        Ok(())
    }
    #[doc=include_str!("untested_safety_msg.txt")]
    /// In-place initializer. If this returns Ok(()), you may perform a conversion to Self via TryFromBytes::try_mut_from_bytes
    ///
    /// # Errors
    ///
    /// Will return Err on allocation failure or if a variable length component exceeeds the maximum encodable size for this packet.
    ///
    /// | Component | Max Size |
    /// |:---------:|:--------:|
    /// |  serv_msg |   65535  |
    /// |    data   |   65535  |
    /// | # of args |    255   |
    /// |  each arg |    255   |
    #[allow(clippy::missing_panics_doc, reason = "infallible")] // size_for_metadata only called after length ck
    pub unsafe fn new_in<A: Allocator>(the_alloc: A, status: AuthorStatus, args: &[&[u8]], server_msg: &[u8], data: &[u8]) -> Result<Box<Self, A>, TacpErr> { unsafe {
        use core::alloc::Layout;
        use core::slice::from_raw_parts_mut as mk_slice;
        use core::ptr::NonNull;
        max!(u8, args);
        max!(u16, server_msg, data);
        arg_len!(args);
        let len = Self::size_for_metadata(server_msg.len() + data.len() + args.len() + args.iter().fold(0, |acc, arg|acc+arg.len())).unwrap();
        let layout = Layout::array::<u8>(len)?;
        let ptr = the_alloc.allocate(layout)?.as_ptr().cast::<u8>();
        if let Err(e) = Self::initialize(mk_slice(ptr, len), status, args, server_msg, data) {
            the_alloc.deallocate(NonNull::new_unchecked(ptr), layout);
            return Err(e);
        }
        let sliced = mk_slice(ptr, len);
        let typed_ptr = match Self::try_mut_from_bytes(sliced) {
            Ok(typed_ref) => core::ptr::from_mut(typed_ref),
            Err(e) => {
                let e: TacpErr = e.into();
                the_alloc.deallocate(NonNull::new_unchecked(ptr), layout);
                return Err(e);
            },
        };
        Ok(Box::from_raw_in(typed_ptr, the_alloc))
    }}
    #[doc=include_str!("untested_safety_msg.txt")]
    ///
    /// # Errors
    ///
    /// Will return Err on allocation failure or if a variable length component exceeeds the maximum encodable size for this packet.
    ///
    /// | Component | Max Size |
    /// |:---------:|:--------:|
    /// |  serv_msg |   65535  |
    /// |    data   |   65535  |
    /// | # of args |    255   |
    /// |  each arg |    255   |
    pub unsafe fn new(status: AuthorStatus, args: &[&[u8]], server_msg: &[u8], data: &[u8]) -> Result<Box<Self>, TacpErr> { unsafe {
        Self::new_in(alloc::alloc::Global, status, args, server_msg, data)
    }}
}

/// Status of the Authorization Request
#[repr(u8)]
#[derive(Debug, Clone, Copy, KnownLayout, Unaligned, TryFromBytes, IntoBytes, Immutable)]
pub enum AuthorStatus {
    /// Authorized as-is
    PASS_ADD = 0x1,
    /// Authroized, but the client must use the provided argument-value pairs instead of the
    /// provided ones.
    PASS_REPL = 0x2,
    /// Authorization Denied
    FAIL = 0x10,
    /// Server error
    ERROR = 0x11,
    /// Follow to other TACACS+ server (deprecated)
    FOLLOW = 0x21,
}

/**
The Account REQUEST Packet Body

Encoding:
```
 1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8
+----------------+----------------+----------------+----------------+
|      flags     |  authen_method |    priv_lvl    |  authen_type   |
+----------------+----------------+----------------+----------------+
| authen_service |    user_len    |    port_len    |  rem_addr_len  |
+----------------+----------------+----------------+----------------+
|    arg_cnt     |   arg_1_len    |   arg_2_len    |      ...       |
+----------------+----------------+----------------+----------------+
|   arg_N_len    |    user ...
+----------------+----------------+----------------+----------------+
|   port ...
+----------------+----------------+----------------+----------------+
|   rem_addr ...
+----------------+----------------+----------------+----------------+
|   arg_1 ...
+----------------+----------------+----------------+----------------+
|   arg_2 ...
+----------------+----------------+----------------+----------------+
|   ...
+----------------+----------------+----------------+----------------+
|   arg_N ...
+----------------+----------------+----------------+----------------+
```
*/
#[repr(C, packed)]
#[derive(KnownLayout, Unaligned, TryFromBytes, IntoBytes, Immutable)]
pub struct AcctRequestPacket {
    pub flags: AcctFlags,
    pub method: AuthorMethod,
    pub priv_level: PrivLevel,
    pub authen_type: AuthenType,
    pub authen_svc: AuthenService,
    pub user_len: u8,
    pub port_len: u8,
    pub rem_addr_len: u8,
    pub arg_cnt: u8,
    pub varidata: [u8]
}
impl AcctRequestPacket {
    pub fn get_user(&self) -> Option<&[u8]> {
        let start = self.arg_cnt as usize;
        let end = start + self.user_len as usize;
        if end-start == 0 {
            return None;
        }
        Some(&self.varidata[start..end])
    }
    pub fn get_port(&self) -> Option<&[u8]> {
        let start = self.arg_cnt as usize + self.user_len as usize;
        let end = start + self.port_len as usize;
        if end-start == 0 {
            return None;
        }
        Some(&self.varidata[start..end])
    }
    pub fn get_rem_addr(&self) -> Option<&[u8]> {
        let start = self.arg_cnt as usize + self.user_len as usize + self.port_len as usize;
        let end = start + self.rem_addr_len as usize;
        if end-start == 0 {
            return None;
        }
        Some(&self.varidata[start..end])
    }
    pub fn get_raw_argvalpair(&self, idx: u8) -> Option<&[u8]> {
        if idx > self.arg_cnt {
            return None;
        }
        let arg_len = self.varidata[idx as usize] as usize;
        let mut skip = 
            self.arg_cnt as usize
            + self.user_len as usize
            + self.port_len as usize
            + self.rem_addr_len as usize;
        for n in 0..idx {
            skip += self.varidata[n as usize] as usize;
        }
        Some(&self.varidata[skip..(skip+arg_len)])
    }
    pub fn iter_args(&self) -> ArgValPairIter<'_> {
        let lengths_range = 0..(self.arg_cnt as usize);
        let data_range_base = 
            self.arg_cnt as usize + self.user_len as usize + self.port_len as usize + self.rem_addr_len as usize;
        ArgValPairIter::new(self.arg_cnt, &self.varidata[lengths_range], &self.varidata[data_range_base..])
    }
    #[allow(clippy::missing_panics_doc, reason = "infallible")] // self had to be constructed so it can not be over the isize limit
    pub fn len(&self) -> usize {
        Self::size_for_metadata(self.varidata.len()).unwrap()
    }
}
#[cfg(feature = "dst-construct")]
impl AcctRequestPacket {
    #[doc=include_str!("untested_safety_msg.txt")]
    #[allow(clippy::missing_panics_doc, reason = "infallible")] // debug_assert + we shouldn't be having layout issues
    pub unsafe fn boxed_to_bytes<A: Allocator>(s: Box<Self, A>) -> Box<[u8], A> {
        use alloc::alloc::Layout;
        let real_len = s.len();
        let (ptr, allocator) = Box::into_raw_with_allocator(s);
        unsafe { debug_assert!(Layout::for_value_raw(ptr) == Layout::array::<u8>(real_len).unwrap()); }
        unsafe { Box::from_raw_in(core::ptr::slice_from_raw_parts_mut(ptr.cast::<u8>(), real_len), allocator) }
    }
    /// In-place initializer. If this returns Ok(()), you may perform a conversion to Self via TryFromBytes::try_mut_from_bytes
    ///
    /// # Errors
    ///
    /// Will return Err if not enough memory is provided to initilize the packet or if a variable length component exceeeds the maximum encodable size for this packet.
    ///
    /// | Component | Max Size |
    /// |:---------:|:--------:|
    /// |    user   |    255   |
    /// |    port   |    255   |
    /// |  rem_addr |    255   |
    /// | # of args |    255   |
    /// |  each arg |    255   |
    #[allow(clippy::missing_panics_doc, reason = "infallible")] // size_for_metadata only called after length ck + debug_assert
    pub fn initialize(mem: &mut [u8], flags: AcctFlags, method: AuthorMethod, priv_level: PrivLevel, authen_type: AuthenType, authen_svc: AuthenService, user: &[u8], port: &[u8], rem_addr: &[u8], args:&[&[u8]]) -> Result<(), TacpErr> {
        max!(u8, user,  port, rem_addr, args);
        arg_len!(args);
        let len = mem.len();
        let required_mem = Self::size_for_metadata(user.len() + port.len() + rem_addr.len() + args.len() + args.iter().fold(0, |acc, arg|acc+arg.len())).unwrap();
        if len < required_mem {
            return Err(TacpErr::BufferSize { required_size: required_mem, given_size: len });
        }
        mem[0] = flags as u8;
        mem[1] = method as u8;
        mem[2] = priv_level;
        mem[3] = authen_type as u8;
        mem[4] = authen_svc as u8;
        #[allow(clippy::cast_possible_truncation)] {
        mem[5] = user.len() as u8;
        mem[6] = port.len() as u8;
        mem[7] = rem_addr.len() as u8;
        mem[9] = args.len() as u8;
        }
        let fixed_part = Self::size_for_metadata(0usize).unwrap();
        let mut varidata_ptr = fixed_part + args.len();
        mem_cpy!(mem, varidata_ptr, user, port, rem_addr);
        for (arg_idx, arg) in args.iter().enumerate() {
            #[allow(clippy::cast_possible_truncation)]
            let arg_len = arg.len() as u8;
            mem[fixed_part+arg_idx] = arg_len;
            mem[varidata_ptr..(varidata_ptr+arg_len as usize)].copy_from_slice(arg);
            varidata_ptr += arg_len as usize;
        }
        debug_assert!(varidata_ptr == required_mem);
        Ok(())
    }
    #[doc=include_str!("untested_safety_msg.txt")]
    ///
    /// # Errors
    ///
    /// Will return Err on allocation failure or if a variable length component exceeeds the maximum encodable size for this packet.
    ///
    /// | Component | Max Size |
    /// |:---------:|:--------:|
    /// |    user   |    255   |
    /// |    port   |    255   |
    /// |  rem_addr |    255   |
    /// | # of args |    255   |
    /// |  each arg |    255   |
    #[allow(clippy::missing_panics_doc, reason = "infallible")] // size_for_metadata only called after length ck
    pub unsafe fn new_in<A: Allocator>(the_alloc: A, flags: AcctFlags, method: AuthorMethod, priv_level: PrivLevel, authen_type: AuthenType, authen_svc: AuthenService, user: &[u8], port: &[u8], rem_addr: &[u8], args:&[&[u8]]) -> Result<Box<Self, A>, TacpErr> {unsafe {
        use core::alloc::Layout;
        use core::slice::from_raw_parts_mut as mk_slice;
        use core::ptr::NonNull;
        max!(u8, user,  port, rem_addr, args);
        arg_len!(args);
        let len = Self::size_for_metadata(user.len() + port.len() + rem_addr.len() + args.len() + args.iter().fold(0, |acc, arg|acc+arg.len())).unwrap();
        let layout = Layout::array::<u8>(len)?;
        let ptr = the_alloc.allocate(layout)?.as_ptr().cast::<u8>();
        if let Err(e) = Self::initialize(mk_slice(ptr, len), flags, method, priv_level, authen_type, authen_svc, user, port, rem_addr, args) {
            the_alloc.deallocate(NonNull::new_unchecked(ptr), layout);
            return Err(e);
        }
        let sliced = mk_slice(ptr, len);
        let typed_ptr = match Self::try_mut_from_bytes(sliced) {
            Ok(typed_ref) => core::ptr::from_mut(typed_ref),
            Err(e) => {
                let e: TacpErr = e.into();
                the_alloc.deallocate(NonNull::new_unchecked(ptr), layout);
                return Err(e);
            },
        };
        Ok(Box::from_raw_in(typed_ptr, the_alloc))
    }}
    #[doc=include_str!("untested_safety_msg.txt")]
    ///
    /// # Errors
    ///
    /// Will return Err on allocation failure or if a variable length component exceeeds the maximum encodable size for this packet.
    ///
    /// | Component | Max Size |
    /// |:---------:|:--------:|
    /// |    user   |    255   |
    /// |    port   |    255   |
    /// |  rem_addr |    255   |
    /// | # of args |    255   |
    /// |  each arg |    255   |
    pub unsafe fn new(flags: AcctFlags, method: AuthorMethod, priv_level: PrivLevel, authen_type: AuthenType, authen_svc: AuthenService, user: &[u8], port: &[u8], rem_addr: &[u8], args:&[&[u8]]) -> Result<Box<Self>, TacpErr> {unsafe {
        Self::new_in(alloc::alloc::Global, flags, method, priv_level, authen_type, authen_svc, user, port, rem_addr, args)
    }}
}

/**
Accounting Flags

Parsed from the first byte of the Accounting REQUEST packet according to the following tables
(RFC8907 Section 7.2)


| Watchdog | Stop | Start | Flags & 0xE | Meaning                 |
|----------|------|-------|-------------|-------------------------|
| 0        | 0    | 0     | 0           | INVALID                 |
| 0        | 0    | 1     | 2           | Start Accounting Record |
| 0        | 1    | 0     | 4           | Stop Accounting Record  |
| 0        | 1    | 1     | 6           | INVALID                 |
| 1        | 0    | 0     | 8           | Watchdog, no update     |
| 1        | 0    | 1     | A           | Watchdog, with update   |
| 1        | 1    | 0     | C           | INVALID                 |
| 1        | 1    | 1     | E           | INVALID                 |

where:

`FLAG_START` = 0x2

`FLAG_STOP` = 0x4

`FLAG_WATCHDOG` = 0x8
*/
#[repr(u8)]
#[derive(Debug, Clone, Copy, KnownLayout, Unaligned, TryFromBytes, IntoBytes, Immutable)]
pub enum AcctFlags {
    RecordStart = 0x2,
    RecordStop = 0x4,
    WatchdogNoUpdate = 0x8,
    WatchdogUpdate = 0xA,
}


/**
The Accounting REPLY Packet Body

Encoding:
```
 1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8
+----------------+----------------+----------------+----------------+
|         server_msg len          |            data_len             |
+----------------+----------------+----------------+----------------+
|     status     |         server_msg ...
+----------------+----------------+----------------+----------------+
|     data ...
+----------------+
```
*/
#[repr(C, packed)]
#[derive(KnownLayout, Unaligned, TryFromBytes, IntoBytes, Immutable)]
pub struct AcctReplyPacket {
    pub server_msg_len: U16,
    pub data_len: U16,
    pub status: AcctStatus,
    pub varidata: [u8]
}
impl AcctReplyPacket {
    pub fn get_serv_msg(&self) -> Option<&[u8]> {
        let start = 0usize;
        let end = start + self.server_msg_len.get() as usize;
        if end-start == 0 {
            return None;
        }
        Some(&self.varidata[start..end])
    }
    pub fn get_data(&self) -> Option<&[u8]> {
        let start = self.server_msg_len.get() as usize;
        let end = start + self.data_len.get() as usize;
        if end-start == 0 {
            return None;
        }
        Some(&self.varidata[start..end])
    }
    #[allow(clippy::missing_panics_doc, reason = "infallible")] // self had to be constructed so it can not be over the isize limit
    pub fn len(&self) -> usize {
        Self::size_for_metadata(self.varidata.len()).unwrap()
    }
}
#[cfg(feature = "dst-construct")]
impl AcctReplyPacket {
    /// In-place initializer. If this returns Ok(()), you may perform a conversion to Self via TryFromBytes::try_mut_from_bytes
    ///
    /// # Errors
    ///
    /// Will return Err if not enough memory is provided to initilize the packet or if a variable length component exceeeds the maximum encodable size for this packet.
    ///
    /// | Component | Max Size |
    /// |:---------:|:--------:|
    /// |  serv_msg |   65535  |
    /// |    data   |   65535  |
    #[allow(clippy::missing_panics_doc, reason = "infallible")] // size_for_metadata only called after length ck + debug_assert
    pub fn initialize(mem: &mut [u8], status: AcctStatus, server_msg: &[u8], data: &[u8]) -> Result<(), TacpErr> {
        max!(u16,  server_msg, data);
        let len = mem.len();
        let required_mem = Self::size_for_metadata(server_msg.len() + data.len()).unwrap();
        if len < required_mem {
            return Err(TacpErr::BufferSize { required_size: required_mem, given_size: len });
        }
        #[allow(clippy::cast_possible_truncation)]
        let server_msg_len_be = U16::new(server_msg.len() as u16);
        let server_msg_len_bytes = server_msg_len_be.as_bytes();
        #[allow(clippy::cast_possible_truncation)]
        let data_len_be = U16::new(data.len() as u16);
        let data_len_bytes = data_len_be.as_bytes();
        mem[0] = server_msg_len_bytes[0];
        mem[1] = server_msg_len_bytes[1];
        mem[2] = data_len_bytes[0];
        mem[3] = data_len_bytes[1];
        mem[4] = status as u8;
        let mut varidata_ptr = Self::size_for_metadata(0usize).unwrap();
        mem_cpy!(mem, varidata_ptr, server_msg, data);
        debug_assert!(varidata_ptr == required_mem);
        Ok(())
    }
    #[doc=include_str!("untested_safety_msg.txt")]
    ///
    /// # Errors
    ///
    /// Will return Err on allocation fauilure or if a variable length component exceeeds the maximum encodable size for this packet.
    ///
    /// | Component | Max Size |
    /// |:---------:|:--------:|
    /// |  serv_msg |   65535  |
    /// |    data   |   65535  |
    #[allow(clippy::missing_panics_doc, reason = "infallible")] // size_for_metadata only called after length ck
    pub unsafe fn new_in<A: Allocator>(the_alloc: A, status: AcctStatus, server_msg: &[u8], data: &[u8]) -> Result<Box<Self, A>, TacpErr> { unsafe {
        use core::alloc::Layout;
        use core::slice::from_raw_parts_mut as mk_slice;
        use core::ptr::NonNull;
        max!(u16,  server_msg, data);
        let len = Self::size_for_metadata(server_msg.len() + data.len()).unwrap();
        let layout = Layout::array::<u8>(len)?;
        let ptr = the_alloc.allocate(layout)?.as_ptr().cast::<u8>();
        if let Err(e) = Self::initialize(mk_slice(ptr, len), status, server_msg, data) {
            the_alloc.deallocate(NonNull::new_unchecked(ptr), layout);
            return Err(e);
        }
        let sliced = mk_slice(ptr, len);
        let typed_ptr = match Self::try_mut_from_bytes(sliced) {
            Ok(typed_ref) => core::ptr::from_mut(typed_ref),
            Err(e) => {
                let e: TacpErr = e.into();
                the_alloc.deallocate(NonNull::new_unchecked(ptr), layout);
                return Err(e);
            },
        };
        Ok(Box::from_raw_in(typed_ptr, the_alloc))
    }}
    #[doc=include_str!("untested_safety_msg.txt")]
    ///
    /// # Errors
    ///
    /// Will return Err on allocation fauilure or if a variable length component exceeeds the maximum encodable size for this packet.
    ///
    /// | Component | Max Size |
    /// |:---------:|:--------:|
    /// |  serv_msg |   65535  |
    /// |    data   |   65535  |
    pub unsafe fn new(status: AcctStatus, server_msg: &[u8], data: &[u8]) -> Result<Box<Self>, TacpErr> { unsafe {
        Self::new_in(alloc::alloc::Global, status, server_msg, data)
    }}

    #[doc=include_str!("untested_safety_msg.txt")]
    #[allow(clippy::missing_panics_doc, reason = "infallible")] // debug_assert + we shouldn't be having layout issues
    pub unsafe fn boxed_to_bytes<A: Allocator>(s: Box<Self, A>) -> Box<[u8], A> {
        use alloc::alloc::Layout;
        let real_len = s.len();
        let (ptr, allocator) = Box::into_raw_with_allocator(s);
        unsafe { debug_assert!(Layout::for_value_raw(ptr) == Layout::array::<u8>(real_len).unwrap()); }
        unsafe { Box::from_raw_in(core::ptr::slice_from_raw_parts_mut(ptr.cast::<u8>(), real_len), allocator) }
    }
}

/// Accounting Status Field
#[repr(u8)]
#[derive(Debug, Clone, Copy, KnownLayout, Unaligned, TryFromBytes, IntoBytes, Immutable)]
pub enum AcctStatus {
    SUCCESS = 0x1,
    ERROR = 0x2,
}

/// Unified Error type for this crate
#[derive(Debug, Clone)]
pub enum TacpErr {
    /// An error in parsing a packet or field with an explanation.
    ParseError(&'static str),
    /// An error in allocation.
    AllocError(&'static str),
    /// The provided buffer is not large enough to encode the packet.
    BufferSize { required_size: usize, given_size: usize },
    /// Failure converting packet bytes to UTF-8 string.
    Utf8ConversionError(alloc::str::Utf8Error),
    /// Failure to encode a packet component due to it being too large to fit in the specified packet.
    OversizedComponent { component_name: &'static str, component_size: usize, max_size: usize },
    /// Failure to encode a packet argument due to it being too large.
    /// All arguments have a maximum size of 255.
    OversizedArgument { arg_index: usize, arg_len: usize },
}

impl core::fmt::Display for TacpErr {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::ParseError(d) =>
                write!(f, "parsing failure: {d}"),
            Self::AllocError(d) =>
                write!(f, "allocation failure: {d}"),
            Self::BufferSize { required_size, given_size } =>
                write!(f, "{required_size} bytes required for this operation but were provided only {given_size}"),
            Self::Utf8ConversionError(inner) =>
                inner.fmt(f),
            Self::OversizedComponent { component_name, component_size, max_size } =>
                write!(f, "component {component_name} too large to be encoded into this packet. {component_size} > {max_size}"),
            Self::OversizedArgument { arg_index, arg_len } =>
                write!(f, "argument #{arg_index} with length {arg_len} too large (>255)"),
        }
    }
}

impl core::error::Error for TacpErr {}

impl<S, D> From<zerocopy::error::AlignmentError<S, D>> for TacpErr {
    fn from(_: zerocopy::error::AlignmentError<S, D>) -> Self {
        // No really, we went out of our way to make things unaligned...
        Self::ParseError("Alignment error: this is should never happen")
    }
}

impl<S, D> From<zerocopy::error::SizeError<S,D>> for TacpErr {
    fn from(_value: zerocopy::error::SizeError<S,D>) -> Self {
        Self::ParseError("ZC size error")
    }
}

impl<S, D: ?Sized + TryFromBytes> From<TryCastError<S, D>> for TacpErr {
    fn from(value: TryCastError<S, D>) -> Self {
        match value {
            ConvertError::Alignment(_) => Self::ParseError("Alignment error: this is should never happen"),
            ConvertError::Size(_) => Self::ParseError("ZC size error"),
            ConvertError::Validity(_) => Self::ParseError("ZC Failed to validate"),
        }
    }
}

impl From<core::alloc::LayoutError> for TacpErr {
    fn from(_: core::alloc::LayoutError) -> Self {
        Self::AllocError("LayoutError: requested allocation would overflow isize (max_size_for_align [u8])")
    }
}

impl From<core::alloc::AllocError> for TacpErr {
    fn from(_: core::alloc::AllocError) -> Self {
        Self::AllocError("AllocError: allocation failure")
    }
}

impl From<alloc::str::Utf8Error> for TacpErr {
    fn from(value: alloc::str::Utf8Error) -> Self {
        Self::Utf8ConversionError(value)
    }
}